<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>PyTorch官方文档之torch.Tensor</title>
    <link href="/2020/05/16/PyTorch%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E4%B9%8Btorch-Tensor/"/>
    <url>/2020/05/16/PyTorch%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E4%B9%8Btorch-Tensor/</url>
    
    <content type="html"><![CDATA[<p>torch分别定义了CPU中存储和GPU中存储的两种类型.</p><a id="more"></a><table><thead><tr><th>Data type</th><th>dtype</th><th>CPU tensor</th><th>GPU tensor</th></tr></thead><tbody><tr><td>32-bit floating point</td><td>torch.float32 or torch.float</td><td>torch.FloatTensor</td><td>torch.cuda.FloatTensor</td></tr><tr><td>64-bit floating point</td><td>torch.float64 or torch.double</td><td>torch.DoubleTensor</td><td>torch.cuda.DoubleTensor</td></tr><tr><td>16-bit floating point</td><td>torch.float16 or torch.half</td><td>torch.HalfTensor</td><td>torch.cuda.HalfTensor</td></tr><tr><td>8-bit integer (unsigned)</td><td>torch.uint8</td><td>torch.ByteTensor</td><td>torch.cuda.ByteTensor</td></tr><tr><td>8-bit integer (signed)</td><td>torch.int8</td><td>torch.CharTensor</td><td>torch.cuda.CharTensor</td></tr><tr><td>16-bit integer (signed)</td><td>torch.int16 or torch.short</td><td>torch.ShortTensor</td><td>torch.cuda.ShortTensor</td></tr><tr><td>32-bit integer (signed)</td><td>torch.int32 or torch.int</td><td>torch.IntTensor</td><td>torch.cuda.IntTensor</td></tr><tr><td>64-bit integer (signed)</td><td>torch.int64 or torch.long</td><td>torch.LongTensor</td><td>torch.cuda.LongTensor</td></tr><tr><td>Boolean</td><td>torch.bool</td><td>torch.BoolTensor</td><td>torch.cuda.BoolTensor</td></tr><tr><td>torch.Tensor()等于就是torch.FloatTensor()</td><td></td><td></td><td></td></tr></tbody></table><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</code></pre><pre><code class="hljs python">a = torch.Tensor(<span class="hljs-number">1</span>) <span class="hljs-comment"># torch.Tensor()就是默认数据类型为torch.FloatTensor()的张量</span>b = torch.FloatTensor(<span class="hljs-number">1</span>)a,b <span class="hljs-comment"># torch.Tensor()创建一个默认类型为torch.FloatTensor()的张量,torch.FloatTensor()是CPU中类型</span></code></pre><pre><code>(tensor([1.4013e-45]), tensor([1.4013e-45]))</code></pre><p>使用Python中的list创建tensor张量,或者使用np.array()也可以</p><pre><code class="hljs python">a = torch.tensor([[<span class="hljs-number">1.</span>, <span class="hljs-number">-1.</span>], [<span class="hljs-number">1.</span>, <span class="hljs-number">-1.</span>]]) <span class="hljs-comment"># 注意,这里创建的是内容为1.和-1.的tensor,不是维度,</span>b = torch.tensor(((<span class="hljs-number">1.</span>, <span class="hljs-number">-1.</span>), (<span class="hljs-number">1.</span>, <span class="hljs-number">-1.</span>))) <span class="hljs-comment"># 并且,这里用[]或()都一样</span>a, b</code></pre><pre><code>(tensor([[ 1., -1.],         [ 1., -1.]]), tensor([[ 1., -1.],         [ 1., -1.]]))</code></pre><pre><code class="hljs python">torch.tensor(np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]]))</code></pre><pre><code>tensor([[1, 2, 3],        [4, 5, 6]], dtype=torch.int32)</code></pre><p>PS: 使用requires_grad_()或者detach()允许更改requires_grad的标志<br>使用torch.dtype指定类型,使用torch.device指定存储的位置</p><pre><code class="hljs python">torch.zeros([<span class="hljs-number">2</span>, <span class="hljs-number">4</span>], dtype=torch.int32)</code></pre><pre><code>tensor([[0, 0, 0, 0],        [0, 0, 0, 0]], dtype=torch.int32)</code></pre><pre><code class="hljs python">cuda = torch.device(<span class="hljs-string">'cuda:0'</span>)torch.ones([<span class="hljs-number">2</span>, <span class="hljs-number">4</span>], dtype=torch.float64, device=cuda)</code></pre><pre><code>tensor([[1., 1., 1., 1.],        [1., 1., 1., 1.]], device=&apos;cuda:0&apos;, dtype=torch.float64)</code></pre><p>索引:可以使用Python的索引方式</p><pre><code class="hljs python">x = torch.tensor([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])print(x)print(x[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>])print(x[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])x[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">8</span>print(x)</code></pre><pre><code>tensor([[1, 2, 3],        [4, 5, 6]])tensor(6)tensor(6)tensor([[1, 8, 3],        [4, 5, 6]])</code></pre><p>使用<code>torch.Tensor.item()</code>返回张量的值</p><pre><code class="hljs python">x = torch.tensor([[<span class="hljs-number">1</span>]])print(x)print(x.item())x = torch.tensor(<span class="hljs-number">2.5</span>)print(x)print(x.item())</code></pre><pre><code>tensor([[1]])1tensor(2.5000)2.5</code></pre><p>使用<code>requires_grad=True</code>让tensor张量能够记下操作记录,以致于可以求导</p><pre><code class="hljs python">x = torch.tensor([[<span class="hljs-number">1.</span>, <span class="hljs-number">-1.</span>], [<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>]], requires_grad=<span class="hljs-literal">True</span>)out = x.pow(<span class="hljs-number">2</span>).sum() <span class="hljs-comment"># out = x^2</span>out.backward() <span class="hljs-comment"># 求导:out = 2 * x</span>print(x.grad)</code></pre><pre><code>tensor([[ 2., -2.],        [ 2.,  2.]])</code></pre><p>NOTE:当需要改变现存的tensor的device时,使用<code>to()</code>方法</p><h1 id="CLASS-torch-Tensor"><a href="#CLASS-torch-Tensor" class="headerlink" title="CLASS torch.Tensor"></a>CLASS torch.Tensor</h1><p>有几种创建tensor的方式</p><ol><li>用上述的<code>torch.tensor()</code>创建</li><li>用torch.*来创建指定size的张量</li><li>用一个张量的size来创建不同类型的张量,使用torch.*_like</li><li>用一个张量的类型创建不同size的张量,使用torch.new_*</li></ol><p>例如:<code>torch.rand(),torch.rand_like(),torch.randn(),torch.randn_like()</code><br><code>,torch.randint(),torch.randint_like(),torch.randperm(),torch.empty()</code></p><h2 id="new-tensor-data"><a href="#new-tensor-data" class="headerlink" title="new_tensor(data)"></a>new_tensor(data)</h2><p>创建一个数据为data其他都为原tensor类型的一个张量</p><pre><code class="hljs python">t = torch.ones((<span class="hljs-number">2</span>, ), dtype=torch.int8)data = [[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]]t.new_tensor(data)</code></pre><pre><code>tensor([[0, 1],        [2, 3]], dtype=torch.int8)</code></pre><h2 id="new-full-size-fill-value"><a href="#new-full-size-fill-value" class="headerlink" title="new_full(size, fill_value)"></a>new_full(size, fill_value)</h2><p>返回一个用fill_value填充的size维度的Tensor,默认返回的dtype和device相同<br>fill_value标量</p><pre><code class="hljs python">t = torch.ones((<span class="hljs-number">2</span>, ), dtype=torch.float64)t.new_full((<span class="hljs-number">3</span>, <span class="hljs-number">4</span>), <span class="hljs-number">3.141592</span>)</code></pre><pre><code>tensor([[3.1416, 3.1416, 3.1416, 3.1416],        [3.1416, 3.1416, 3.1416, 3.1416],        [3.1416, 3.1416, 3.1416, 3.1416]], dtype=torch.float64)</code></pre><h2 id="new-empty-size"><a href="#new-empty-size" class="headerlink" title="new_empty(size)"></a>new_empty(size)</h2><p>返回size维度的用随机初始化数据填充的Tensor</p><pre><code class="hljs python">t = torch.ones((<span class="hljs-number">1</span> ))print(t)t.new_empty((<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))</code></pre><pre><code>tensor([1.])tensor([[0.0000e+00, 0.0000e+00, 1.4013e-45],        [0.0000e+00, 1.4013e-45, 0.0000e+00]])</code></pre><h2 id="new-ones-size"><a href="#new-ones-size" class="headerlink" title="new_ones(size)"></a>new_ones(size)</h2><p>返回一个size维度但是用1填充的Tensor</p><pre><code class="hljs python">t = torch.tensor((<span class="hljs-number">2.</span>))<span class="hljs-comment">#, dtype=torch.int32)</span>print(t.dtype)print(t.new_ones((<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)))print(t)</code></pre><pre><code>torch.float32tensor([[1., 1., 1.],        [1., 1., 1.]])tensor(2.)</code></pre><h2 id="new-zeros-size"><a href="#new-zeros-size" class="headerlink" title="new_zeros(size)"></a>new_zeros(size)</h2><p>返回一个size大小用0填充的Tensor</p><pre><code class="hljs python">tensor = torch.tensor((), dtype=torch.float64)tensor.new_zeros((<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))</code></pre><pre><code>tensor([[0., 0., 0.],        [0., 0., 0.]], dtype=torch.float64)</code></pre><h2 id="is-cuda"><a href="#is-cuda" class="headerlink" title="is_cuda()"></a>is_cuda()</h2><p>如果tensor存储在GPU中返回True,否则返回False</p><h2 id="is-quantized"><a href="#is-quantized" class="headerlink" title="is_quantized()"></a>is_quantized()</h2><p>如果tensor是量化的返回True,否则返回False</p><h2 id="device"><a href="#device" class="headerlink" title="device"></a>device</h2><p>返回Tensor存在哪</p><h2 id="grad"><a href="#grad" class="headerlink" title="grad"></a>grad</h2><p>记录求导<code>backward()</code>之后变量的值</p><h2 id="ndim"><a href="#ndim" class="headerlink" title="ndim"></a>ndim</h2><p>dim()的别名,返回的tensor的维度</p><h2 id="T"><a href="#T" class="headerlink" title="T"></a>T</h2><p>返回矩阵的转置</p><pre><code class="hljs python">x = torch.tensor([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]])print(x)print(x.T)</code></pre><pre><code>tensor([[0, 1],        [2, 3]])tensor([[0, 2],        [1, 3]])</code></pre><h2 id="abs-abs"><a href="#abs-abs" class="headerlink" title="abs() / abs_()"></a>abs() / abs_()</h2><p>与torch.abs()相同,返回矩阵中元素的绝对值</p><pre><code class="hljs python">torch.tensor([<span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">3</span>]).abs()</code></pre><pre><code>tensor([1, 2, 3])</code></pre><h2 id="acos-acos"><a href="#acos-acos" class="headerlink" title="acos() / acos_()"></a>acos() / acos_()</h2><p>与torch.acos()相同,返回arccos反余弦值</p><h2 id="add-other-alpha-1-add"><a href="#add-other-alpha-1-add" class="headerlink" title="add(other, *, alpha=1) / add_()"></a>add(other, *, alpha=1) / add_()</h2><p>与torch.add()相同,返回张量+alpha*other</p><pre><code class="hljs python">x = torch.ones((<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))print(x)x.add(<span class="hljs-number">1</span>, alpha=<span class="hljs-number">2</span>)</code></pre><pre><code>tensor([[1., 1., 1.],        [1., 1., 1.]])tensor([[3., 3., 3.],        [3., 3., 3.]])</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>PyTorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CNN_Dective_kdd99</title>
    <link href="/2020/03/24/CNN-Dective-kdd99/"/>
    <url>/2020/03/24/CNN-Dective-kdd99/</url>
    
    <content type="html"><![CDATA[<h1 id="PyTorch编程时遇到的问题"><a href="#PyTorch编程时遇到的问题" class="headerlink" title="PyTorch编程时遇到的问题"></a>PyTorch编程时遇到的问题</h1><a id="more"></a><h2 id="num-workers-0"><a href="#num-workers-0" class="headerlink" title="num_workers=0"></a>num_workers=0</h2><p>在windows中使用PyTorch中的dataloader中num_workers大于0或1就会提示：BrokenPipeError错误，这种是因为PyTorch调用了multiprocessing库。<a href="https://discuss.pytorch.org/t/、brokenpipeerror-errno-32-broken-pipe-when-i-run-cifar10-tutorial-py/6224/3" target="_blank" rel="noopener">参考</a><br>解决方法：</p><ol><li>将num_workers设置为0或1，也就是不使用多进程</li><li>添加<code>if __name__ == &#39;__main__&#39;:</code>这条语句,windows必须要检测<strong>main</strong>(),否则就会出现错误，参考<a href="https://stackoverflow.com/questions/18204782/runtimeerror-on-windows-trying-python-multiprocessing" target="_blank" rel="noopener">错误</a>，但是在jupyter notebook中使用了这条语句，依旧不管用。<h2 id="张量类型需要统一"><a href="#张量类型需要统一" class="headerlink" title="张量类型需要统一"></a>张量类型需要统一</h2>我们在定义张量时，首先dtype设置为普通类型例如：torch.float32,torch.int64,而不是将其设置为CPU tensor或者GPU tensor，并且网络中的参数也需要将其放入当GPU中(如果使用GPU运算的话)。可以使用这条语句net = net.to(device)<h2 id="注意卷积操作的维度"><a href="#注意卷积操作的维度" class="headerlink" title="注意卷积操作的维度"></a>注意卷积操作的维度</h2>在对CNN网络进行训练时，输入数据为维度为(N, C_in, H, W)输入维度为(N, C_out, H_out, W_out)，如果维度对应不上可以使用unsqueeze和squeeze函数对张量进行增维和降维。<h2 id="还有一个问题"><a href="#还有一个问题" class="headerlink" title="还有一个问题"></a>还有一个问题</h2>这个问题比较玄学，我刚开始几次训练时，CNN的识别率一直不动，保持相同的水平，但是在我们测试所有参数类型是否有问题后，并且运行的代码跟之前相比并没有改变什么变量，但是奇怪的时，识别率不仅大幅提高了，而且随着nepochs次数的增加，识别率也在提高，并且每次训练的时间都减少了。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次很多编程上的问题，都没有注意，还得加强编程的训练，并且加强Linux的学习，毕竟在windows中不能使用多进程加载速度是真滴慢。</p>]]></content>
    
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>入侵检测</tag>
      
      <tag>PyTorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;&lt;基于特征分组聚类的异常入侵检测系统研究&gt;&gt;代码复现</title>
    <link href="/2019/12/02/kdd99/"/>
    <url>/2019/12/02/kdd99/</url>
    
    <content type="html"><![CDATA[<h1 id="导入数据集"><a href="#导入数据集" class="headerlink" title="导入数据集"></a>导入数据集</h1><a id="more"></a><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<span class="hljs-keyword">from</span> sklearn.cluster <span class="hljs-keyword">import</span> KMeanscolumns_names = [<span class="hljs-string">'duration'</span>, <span class="hljs-string">'protocol_type'</span>, <span class="hljs-string">'service'</span>, <span class="hljs-string">'flag'</span>, <span class="hljs-string">'src_bytes'</span>, <span class="hljs-string">'dst_bytes'</span>, <span class="hljs-string">'land'</span>, <span class="hljs-string">'wrong_fragment'</span>, <span class="hljs-string">'urgent'</span>, <span class="hljs-string">'hot'</span>, <span class="hljs-string">'num_failed_logins'</span>, <span class="hljs-string">'logged_in'</span>, <span class="hljs-string">'num_compromised'</span>, <span class="hljs-string">'root_shell'</span>, <span class="hljs-string">'su_attempted'</span>, <span class="hljs-string">'num_root'</span>, <span class="hljs-string">'num_file_creations'</span>, <span class="hljs-string">'num_shells'</span>, <span class="hljs-string">'num_access_files'</span>, <span class="hljs-string">'num_outbound_cmds'</span>, <span class="hljs-string">'is_host_login'</span>, <span class="hljs-string">'is_guest_login'</span>, <span class="hljs-string">'count'</span>, <span class="hljs-string">'srv_count'</span>, <span class="hljs-string">'serror_rate'</span>, <span class="hljs-string">'srv_serror_rate'</span>, <span class="hljs-string">'rerror_rate'</span>, <span class="hljs-string">'srv_rerror_rate'</span>, <span class="hljs-string">'same_srv_rate'</span>, <span class="hljs-string">'diff_srv_rate'</span>, <span class="hljs-string">'srv_diff_host_rate'</span>, <span class="hljs-string">'dst_host_count'</span>, <span class="hljs-string">'dst_host_srv_count'</span>, <span class="hljs-string">'dst_host_same_srv_rate'</span>, <span class="hljs-string">'dst_host_diff_srv_rate'</span>, <span class="hljs-string">'dst_host_same_src_port_rate'</span>, <span class="hljs-string">'dst_host_srv_diff_host_rate'</span>, <span class="hljs-string">'dst_host_serror_rate'</span>, <span class="hljs-string">'dst_host_srv_serror_rate'</span>, <span class="hljs-string">'dst_host_rerror_rate'</span>, <span class="hljs-string">'dst_host_srv_rerror_rate'</span>,<span class="hljs-string">'result'</span>]df = pd.read_csv(<span class="hljs-string">'./Sets/kddcup.data_10_percent/kddcup_10_percent.csv'</span>, names=columns_names)<span class="hljs-comment">#print(df.iloc[:,0:4])</span>kdd_data = df.iloc[:,:<span class="hljs-number">-1</span>]   <span class="hljs-comment"># 保存无标签数据集</span>kdd_target = df.iloc[:,<span class="hljs-number">-1</span>] <span class="hljs-comment"># 保存标签列</span></code></pre><p>输出部分数据，查看是否有误</p><pre><code class="hljs python">print(kdd_data.head())print(kdd_target.head())</code></pre><pre><code>   duration protocol_type service flag  src_bytes  dst_bytes  land  \0         0           tcp    http   SF        181       5450     0   1         0           tcp    http   SF        239        486     0   2         0           tcp    http   SF        235       1337     0   3         0           tcp    http   SF        219       1337     0   4         0           tcp    http   SF        217       2032     0      wrong_fragment  urgent  hot  ...  dst_host_count  dst_host_srv_count  \0               0       0    0  ...               9                   9   1               0       0    0  ...              19                  19   2               0       0    0  ...              29                  29   3               0       0    0  ...              39                  39   4               0       0    0  ...              49                  49      dst_host_same_srv_rate  dst_host_diff_srv_rate  \0                     1.0                     0.0   1                     1.0                     0.0   2                     1.0                     0.0   3                     1.0                     0.0   4                     1.0                     0.0      dst_host_same_src_port_rate  dst_host_srv_diff_host_rate  \0                         0.11                          0.0   1                         0.05                          0.0   2                         0.03                          0.0   3                         0.03                          0.0   4                         0.02                          0.0      dst_host_serror_rate  dst_host_srv_serror_rate  dst_host_rerror_rate  \0                   0.0                       0.0                   0.0   1                   0.0                       0.0                   0.0   2                   0.0                       0.0                   0.0   3                   0.0                       0.0                   0.0   4                   0.0                       0.0                   0.0      dst_host_srv_rerror_rate  0                       0.0  1                       0.0  2                       0.0  3                       0.0  4                       0.0  [5 rows x 41 columns]0    normal.1    normal.2    normal.3    normal.4    normal.Name: result, dtype: object</code></pre><h1 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h1><p>1.将类型为：string的列用one-hot编码数值化<br>2.将编码后的数据，再合并到原来的数据中，并且删除原本数据类型为string的列的数据<br>3.再使用最大最小化归一化</p><h2 id="ont-hot编码"><a href="#ont-hot编码" class="headerlink" title="ont-hot编码"></a>ont-hot编码</h2><pre><code class="hljs python">data = pd.get_dummies(df[[<span class="hljs-string">'protocol_type'</span>, <span class="hljs-string">'service'</span>, <span class="hljs-string">'flag'</span>]])print(len(data.columns))print(len(df.columns))</code></pre><pre><code>8042</code></pre><h2 id="合并数值化后的数据，删除原来string类型的数据"><a href="#合并数值化后的数据，删除原来string类型的数据" class="headerlink" title="合并数值化后的数据，删除原来string类型的数据"></a>合并数值化后的数据，删除原来string类型的数据</h2><pre><code class="hljs python">kdd_data_comb = pd.merge(kdd_data, data, how=<span class="hljs-string">'outer'</span>, left_index=<span class="hljs-literal">True</span>, right_index=<span class="hljs-literal">True</span>)print(kdd_data_comb.shape)<span class="hljs-comment"># print(list(kdd_data_comb.columns))</span><span class="hljs-comment"># print(list(kdd_data.columns))</span><span class="hljs-comment"># print(kdd_data.head())</span>kdd_data_comb = kdd_data_comb.drop(columns=[<span class="hljs-string">'protocol_type'</span>, <span class="hljs-string">'service'</span>, <span class="hljs-string">'flag'</span>])</code></pre><pre><code>(494021, 121)</code></pre><h2 id="数据归一化"><a href="#数据归一化" class="headerlink" title="数据归一化"></a>数据归一化</h2><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> MinMaxScalerscale = MinMaxScaler().fit(kdd_data_comb)kdd_dataScale = scale.transform(kdd_data_comb)</code></pre><h1 id="KMeans降维"><a href="#KMeans降维" class="headerlink" title="KMeans降维"></a>KMeans降维</h1><p>这里将数据按照论文中的方式，将数据集划分为4组，然后对每一组作Kmeans聚类</p><pre><code class="hljs python">model1 = KMeans(n_clusters=<span class="hljs-number">10</span>).fit(kdd_data_comb.loc[:,[<span class="hljs-string">'duration'</span>, <span class="hljs-string">'protocol_type_icmp'</span>, <span class="hljs-string">'protocol_type_tcp'</span>, <span class="hljs-string">'protocol_type_udp'</span>, <span class="hljs-string">'service_IRC'</span>, <span class="hljs-string">'service_X11'</span>, <span class="hljs-string">'service_Z39_50'</span>, <span class="hljs-string">'service_auth'</span>, <span class="hljs-string">'service_bgp'</span>, <span class="hljs-string">'service_courier'</span>, <span class="hljs-string">'service_csnet_ns'</span>, <span class="hljs-string">'service_ctf'</span>, <span class="hljs-string">'service_daytime'</span>, <span class="hljs-string">'service_discard'</span>, <span class="hljs-string">'service_domain'</span>, <span class="hljs-string">'service_domain_u'</span>, <span class="hljs-string">'service_echo'</span>, <span class="hljs-string">'service_eco_i'</span>, <span class="hljs-string">'service_ecr_i'</span>, <span class="hljs-string">'service_efs'</span>, <span class="hljs-string">'service_exec'</span>, <span class="hljs-string">'service_finger'</span>, <span class="hljs-string">'service_ftp'</span>, <span class="hljs-string">'service_ftp_data'</span>, <span class="hljs-string">'service_gopher'</span>, <span class="hljs-string">'service_hostnames'</span>, <span class="hljs-string">'service_http'</span>, <span class="hljs-string">'service_http_443'</span>, <span class="hljs-string">'service_imap4'</span>, <span class="hljs-string">'service_iso_tsap'</span>, <span class="hljs-string">'service_klogin'</span>, <span class="hljs-string">'service_kshell'</span>, <span class="hljs-string">'service_ldap'</span>, <span class="hljs-string">'service_link'</span>, <span class="hljs-string">'service_login'</span>, <span class="hljs-string">'service_mtp'</span>, <span class="hljs-string">'service_name'</span>, <span class="hljs-string">'service_netbios_dgm'</span>, <span class="hljs-string">'service_netbios_ns'</span>, <span class="hljs-string">'service_netbios_ssn'</span>, <span class="hljs-string">'service_netstat'</span>, <span class="hljs-string">'service_nnsp'</span>, <span class="hljs-string">'service_nntp'</span>, <span class="hljs-string">'service_ntp_u'</span>, <span class="hljs-string">'service_other'</span>, <span class="hljs-string">'service_pm_dump'</span>, <span class="hljs-string">'service_pop_2'</span>, <span class="hljs-string">'service_pop_3'</span>, <span class="hljs-string">'service_printer'</span>, <span class="hljs-string">'service_private'</span>, <span class="hljs-string">'service_red_i'</span>, <span class="hljs-string">'service_remote_job'</span>, <span class="hljs-string">'service_rje'</span>, <span class="hljs-string">'service_shell'</span>, <span class="hljs-string">'service_smtp'</span>, <span class="hljs-string">'service_sql_net'</span>, <span class="hljs-string">'service_ssh'</span>, <span class="hljs-string">'service_sunrpc'</span>, <span class="hljs-string">'service_supdup'</span>, <span class="hljs-string">'service_systat'</span>, <span class="hljs-string">'service_telnet'</span>, <span class="hljs-string">'service_tftp_u'</span>, <span class="hljs-string">'service_tim_i'</span>, <span class="hljs-string">'service_time'</span>, <span class="hljs-string">'service_urh_i'</span>, <span class="hljs-string">'service_urp_i'</span>, <span class="hljs-string">'service_uucp'</span>, <span class="hljs-string">'service_uucp_path'</span>, <span class="hljs-string">'service_vmnet'</span>, <span class="hljs-string">'service_whois'</span>, <span class="hljs-string">'flag_OTH'</span>, <span class="hljs-string">'flag_REJ'</span>, <span class="hljs-string">'flag_RSTO'</span>, <span class="hljs-string">'flag_RSTOS0'</span>, <span class="hljs-string">'flag_RSTR'</span>, <span class="hljs-string">'flag_S0'</span>, <span class="hljs-string">'flag_S1'</span>, <span class="hljs-string">'flag_S2'</span>, <span class="hljs-string">'flag_S3'</span>, <span class="hljs-string">'flag_SF'</span>, <span class="hljs-string">'flag_SH'</span>, <span class="hljs-string">'src_bytes'</span>, <span class="hljs-string">'dst_bytes'</span>, <span class="hljs-string">'land'</span>, <span class="hljs-string">'wrong_fragment'</span>, <span class="hljs-string">'urgent'</span>]])model2 = KMeans(n_clusters=<span class="hljs-number">10</span>).fit(kdd_data_comb.loc[:,[<span class="hljs-string">'hot'</span>, <span class="hljs-string">'num_failed_logins'</span>, <span class="hljs-string">'logged_in'</span>, <span class="hljs-string">'num_compromised'</span>, <span class="hljs-string">'root_shell'</span>, <span class="hljs-string">'su_attempted'</span>, <span class="hljs-string">'num_root'</span>, <span class="hljs-string">'num_file_creations'</span>, <span class="hljs-string">'num_shells'</span>, <span class="hljs-string">'num_access_files'</span>, <span class="hljs-string">'num_outbound_cmds'</span>, <span class="hljs-string">'is_host_login'</span>, <span class="hljs-string">'is_guest_login'</span>]])model3 = KMeans(n_clusters=<span class="hljs-number">10</span>).fit(kdd_data_comb.loc[:,[<span class="hljs-string">'count'</span>, <span class="hljs-string">'srv_count'</span>, <span class="hljs-string">'serror_rate'</span>, <span class="hljs-string">'srv_serror_rate'</span>, <span class="hljs-string">'rerror_rate'</span>, <span class="hljs-string">'srv_rerror_rate'</span>, <span class="hljs-string">'same_srv_rate'</span>, <span class="hljs-string">'diff_srv_rate'</span>, <span class="hljs-string">'srv_diff_host_rate'</span>]])model4 = KMeans(n_clusters=<span class="hljs-number">10</span>).fit(kdd_data_comb.loc[:,[<span class="hljs-string">'dst_host_count'</span>, <span class="hljs-string">'dst_host_srv_count'</span>, <span class="hljs-string">'dst_host_same_srv_rate'</span>, <span class="hljs-string">'dst_host_diff_srv_rate'</span>, <span class="hljs-string">'dst_host_same_src_port_rate'</span>, <span class="hljs-string">'dst_host_srv_diff_host_rate'</span>, <span class="hljs-string">'dst_host_serror_rate'</span>, <span class="hljs-string">'dst_host_srv_serror_rate'</span>, <span class="hljs-string">'dst_host_rerror_rate'</span>, <span class="hljs-string">'dst_host_srv_rerror_rate'</span>]])</code></pre><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npnp.unique(model1.labels_) <span class="hljs-comment"># 这里显示聚类结果中所有的值，如果只是打印出来，看不到除0以外的其他值</span></code></pre><pre><code>array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</code></pre><pre><code class="hljs python">sizes = [(model1.labels_ == i).sum() <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>) ] <span class="hljs-comment">#每块值</span>print(sizes)print(len(model1.labels_))</code></pre><pre><code>[491472, 1, 59, 16, 24, 21, 6, 77, 2343, 2]494021</code></pre><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> pltplt.figure(figsize=(<span class="hljs-number">6</span>,<span class="hljs-number">9</span>)) <span class="hljs-comment">#调节图形大小</span>labels = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>] <span class="hljs-comment">#定义标签</span><span class="hljs-comment"># sizes = [i for i in range(10): model1.labels_ == i] #每块值</span>explode = (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) <span class="hljs-comment">#将某一块分割出来，值越大分割出的间隙越大</span>patches,text1,text2 = plt.pie(sizes,                      explode=explode,                      labels=labels,                      autopct = <span class="hljs-string">'%3.2f%%'</span>, <span class="hljs-comment">#数值保留固定小数位</span>                      shadow = <span class="hljs-literal">False</span>, <span class="hljs-comment">#无阴影设置</span>                      startangle =<span class="hljs-number">90</span>, <span class="hljs-comment">#逆时针起始角度设置</span>                      pctdistance = <span class="hljs-number">0.6</span>) <span class="hljs-comment">#数值距圆心半径倍数距离</span><span class="hljs-comment">#patches饼图的返回值，texts1饼图外label的文本，texts2饼图内部的文本</span><span class="hljs-comment"># x，y轴刻度设置一致，保证饼图为圆形</span>plt.axis(<span class="hljs-string">'equal'</span>)plt.show()</code></pre><pre><code>&lt;Figure size 600x900 with 1 Axes&gt;</code></pre><h2 id="合并降维后的数据"><a href="#合并降维后的数据" class="headerlink" title="合并降维后的数据"></a>合并降维后的数据</h2><p>可以看到数据经过kmeans降维后，数据集就变成了只有4维的数据了</p><pre><code class="hljs python">data_kmeansed = pd.DataFrame(&#123;<span class="hljs-string">'model1'</span>: model1.labels_, <span class="hljs-string">'model2'</span>: model2.labels_, <span class="hljs-string">'model3'</span>: model3.labels_, <span class="hljs-string">'model4'</span>: model4.labels_&#125;, columns=[<span class="hljs-string">'model1'</span>, <span class="hljs-string">'model2'</span>, <span class="hljs-string">'model3'</span>, <span class="hljs-string">'model4'</span>])print(data_kmeansed.head())print(data_kmeansed.shape)</code></pre><pre><code>   model1  model2  model3  model40       0       4       2       31       0       4       2       32       0       4       2       33       0       4       2       34       0       4       2       3(494021, 4)</code></pre><pre><code class="hljs python"><span class="hljs-comment"># data_kmeansed_onehot = pd.get_dummies(data_kmeansed[['model1', 'model2', 'model3', 'model4']])</span><span class="hljs-comment"># print(pd.get_dummies(data_kmeansed[['model1', 'model2', 'model3', 'model4']]).head()) # 可以看到这里对数据值数据进行one-hot编码数值不变</span></code></pre><h2 id="标签处理"><a href="#标签处理" class="headerlink" title="标签处理"></a>标签处理</h2><p>该模型只对5种大类型的攻击方式进行预测，但是数据集中原标签全是小类型，需要将小类型的标签，根据攻击方式的不同划分到大类型中</p><pre><code class="hljs python">np.unique(kdd_target) <span class="hljs-comment"># 显示当前标签中的值</span></code></pre><pre><code>array([&apos;back.&apos;, &apos;buffer_overflow.&apos;, &apos;ftp_write.&apos;, &apos;guess_passwd.&apos;,       &apos;imap.&apos;, &apos;ipsweep.&apos;, &apos;land.&apos;, &apos;loadmodule.&apos;, &apos;multihop.&apos;,       &apos;neptune.&apos;, &apos;nmap.&apos;, &apos;normal.&apos;, &apos;perl.&apos;, &apos;phf.&apos;, &apos;pod.&apos;,       &apos;portsweep.&apos;, &apos;rootkit.&apos;, &apos;satan.&apos;, &apos;smurf.&apos;, &apos;spy.&apos;, &apos;teardrop.&apos;,       &apos;warezclient.&apos;, &apos;warezmaster.&apos;], dtype=object)</code></pre><pre><code class="hljs python">kdd_target_test = kdd_target.copy(<span class="hljs-literal">True</span>) <span class="hljs-comment"># 深度复制</span></code></pre><pre><code class="hljs python"><span class="hljs-comment"># 做个映射将标签中的小类，按照先验知识划分为5个大类</span></code></pre><pre><code class="hljs python"><span class="hljs-comment"># print(kdd_target_test[kdd_target_test=='Dos'].head())</span>print(np.unique(kdd_target))</code></pre><pre><code>[&apos;Dos&apos; &apos;R2L&apos; &apos;U2R&apos; &apos;normal&apos; &apos;probe&apos;]</code></pre><p>替换</p><pre><code class="hljs python">Dos_target = &#123;<span class="hljs-string">'back.'</span>:<span class="hljs-string">'Dos'</span>, <span class="hljs-string">'neptune.'</span>:<span class="hljs-string">'Dos'</span>, <span class="hljs-string">'pod.'</span>:<span class="hljs-string">'Dos'</span>, <span class="hljs-string">'smurf.'</span>:<span class="hljs-string">'Dos'</span>, <span class="hljs-string">'land.'</span>:<span class="hljs-string">'Dos'</span>, <span class="hljs-string">'teardrop.'</span>:<span class="hljs-string">'Dos'</span>, <span class="hljs-string">'normal.'</span>:<span class="hljs-string">'normal'</span>,<span class="hljs-string">'ipsweep.'</span>:<span class="hljs-string">'probe'</span>, <span class="hljs-string">'nmap.'</span>:<span class="hljs-string">'probe'</span>, <span class="hljs-string">'portsweep.'</span>:<span class="hljs-string">'probe'</span>, <span class="hljs-string">'satan.'</span>:<span class="hljs-string">'probe'</span>, <span class="hljs-string">'ftp_write.'</span>:<span class="hljs-string">'R2L'</span>, <span class="hljs-string">'guess_passwd.'</span>:<span class="hljs-string">'R2L'</span>, <span class="hljs-string">'imap.'</span>:<span class="hljs-string">'R2L'</span>, <span class="hljs-string">'multihop.'</span>:<span class="hljs-string">'R2L'</span>, <span class="hljs-string">'phf.'</span>:<span class="hljs-string">'R2L'</span>, <span class="hljs-string">'spy.'</span>:<span class="hljs-string">'R2L'</span>, <span class="hljs-string">'warezclient.'</span>:<span class="hljs-string">'R2L'</span>, <span class="hljs-string">'warezmaster.'</span>:<span class="hljs-string">'R2L'</span>, <span class="hljs-string">'buffer_overflow.'</span>:<span class="hljs-string">'U2R'</span>, <span class="hljs-string">'loadmodule.'</span>:<span class="hljs-string">'U2R'</span>, <span class="hljs-string">'perl.'</span>:<span class="hljs-string">'U2R'</span>, <span class="hljs-string">'rootkit.'</span>:<span class="hljs-string">'U2R'</span>&#125;kdd_target = kdd_target_test.map(Dos_target)</code></pre><h1 id="决策树做训练"><a href="#决策树做训练" class="headerlink" title="决策树做训练"></a>决策树做训练</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> treetree_model = tree.DecisionTreeClassifier(criterion=<span class="hljs-string">'entropy'</span>,random_state=<span class="hljs-number">30</span>)<span class="hljs-comment"># criterion='entropy'调用的就是C4.5算法，默认是CART</span>tree_model.fit(data_kmeansed, kdd_target)</code></pre><pre><code>DecisionTreeClassifier(class_weight=None, criterion=&apos;entropy&apos;, max_depth=None,                       max_features=None, max_leaf_nodes=None,                       min_impurity_decrease=0.0, min_impurity_split=None,                       min_samples_leaf=1, min_samples_split=2,                       min_weight_fraction_leaf=0.0, presort=False,                       random_state=30, splitter=&apos;best&apos;)</code></pre><pre><code class="hljs python"><span class="hljs-comment"># data_kmeansed.isnull().sum()</span></code></pre><pre><code>model1    0model2    0model3    0model4    0dtype: int64</code></pre><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_scorenormal_data = data_kmeansed[kdd_target == <span class="hljs-string">'normal'</span>]print(normal_data.shape)</code></pre><pre><code>(97278, 4)</code></pre><pre><code class="hljs python">back_predict = tree_model.predict(normal_data)</code></pre><p>计算各个类的预测成功率</p><pre><code class="hljs python">y_data = []target = [<span class="hljs-string">'Dos'</span>, <span class="hljs-string">'probe'</span>, <span class="hljs-string">'R2L'</span>, <span class="hljs-string">'U2R'</span>,<span class="hljs-string">'normal'</span>]<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> target:    data1 = data_kmeansed[kdd_target == i]        back_predict = tree_model.predict(data1)    y_data.append(accuracy_score(kdd_target[kdd_target == i], back_predict))</code></pre><pre><code class="hljs python">y_data</code></pre><pre><code>[0.9955167604187423, 0.4390065741417093, 0.325044404973357, 0.038461538461538464, 0.9968852155677542]</code></pre><p>各个类的检测率的可视化</p><pre><code class="hljs python">x_data = [<span class="hljs-string">'Dos'</span>, <span class="hljs-string">'probe'</span>, <span class="hljs-string">'R2L'</span>, <span class="hljs-string">'U2R'</span>, <span class="hljs-string">'normal'</span>]bar_width = <span class="hljs-number">0.3</span>plt.bar(x=x_data, height=y_data, label=<span class="hljs-string">'检测正确率'</span>, color=<span class="hljs-string">'steelblue'</span>, alpha=<span class="hljs-number">0.8</span>, width=bar_width)plt.xticks(x_data)plt.show()</code></pre><p><img src="/images/output_35_0.png" srcset="/img/loading.gif" alt="output_35_0"></p><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> confusion_matrixdata1 = data_kmeansedkdd_predict = tree_model.predict(data1)pd.DataFrame(    confusion_matrix(kdd_target, kdd_predict),     columns=[<span class="hljs-string">'预测Dos'</span>, <span class="hljs-string">'预测probe'</span>, <span class="hljs-string">'预测R2L'</span>, <span class="hljs-string">'预测U2R'</span>, <span class="hljs-string">'预测normal'</span>],    index=[<span class="hljs-string">'实际Dos'</span>, <span class="hljs-string">'实际probe'</span>, <span class="hljs-string">'实际R2L'</span>, <span class="hljs-string">'实际U2R'</span>,<span class="hljs-string">'实际normal'</span>])</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th {    vertical-align: top;}.dataframe thead th {    text-align: right;}</code></pre><p></style><p></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>预测Dos</th>      <th>预测probe</th>      <th>预测R2L</th>      <th>预测U2R</th>      <th>预测normal</th>    </tr>  </thead>  <tbody>    <tr>      <td>实际Dos</td>      <td>389703</td>      <td>0</td>      <td>0</td>      <td>1746</td>      <td>9</td>    </tr>    <tr>      <td>实际probe</td>      <td>0</td>      <td>366</td>      <td>0</td>      <td>760</td>      <td>0</td>    </tr>    <tr>      <td>实际R2L</td>      <td>0</td>      <td>0</td>      <td>2</td>      <td>50</td>      <td>0</td>    </tr>    <tr>      <td>实际U2R</td>      <td>225</td>      <td>28</td>      <td>0</td>      <td>96975</td>      <td>50</td>    </tr>    <tr>      <td>实际normal</td>      <td>264</td>      <td>0</td>      <td>0</td>      <td>2040</td>      <td>1803</td>    </tr>  </tbody></table></div><h1 id="计算F1的值"><a href="#计算F1的值" class="headerlink" title="计算F1的值"></a>计算F1的值</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> f1_scoreprint(f1_score(kdd_target, kdd_predict, average=<span class="hljs-literal">None</span>))</code></pre><pre><code>[0.99712915 0.48157895 0.07407407 0.97536322 0.60412129]</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>MachineLearning</tag>
      
      <tag>IDS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通用ShellCode</title>
    <link href="/2019/06/25/%E9%80%9A%E7%94%A8shellcode/"/>
    <url>/2019/06/25/%E9%80%9A%E7%94%A8shellcode/</url>
    
    <content type="html"><![CDATA[<ol><li><p>先将API的hash函数压入栈</p></li><li><p>esi指向esp-0xc</p></li><li><p>清空ebx，移动栈顶指针</p></li><li><p>将user32字符串压入栈中</p></li></ol><a id="more"></a><h3 id="在win-32平台下定位kernel32-dll中的API地址"><a href="#在win-32平台下定位kernel32-dll中的API地址" class="headerlink" title="在win_32平台下定位kernel32.dll中的API地址"></a>在win_32平台下定位kernel32.dll中的API地址</h3><p>（1）段选择字FS在内存中找到当前的线程环境块TEB</p><p>（2）TEB偏移位置0x30的地方存放着指向进程环境块PEB的指针</p><p>（3）进程环境块偏移位置为0x0C的地方存放着指向PEB_LDR_DATA结构体的指针，其中存放着已经被进程装载的动态链接库的信息</p><p>（4）PEB_LDR_DATA结构体偏移位置为0x1C的地方存放着指向模块初始化链表的头指针InInitializationOrderModuleList</p><p>（5）模块化初始化链表InInitializationOrderModuleList中按顺序存放着PE装入运行时初始化模块的信息，第一个链表结点是ntdll.dll，第二个链表结点就是kernel32.dll</p><p>（6）找到属于kernel32.dll的结点后，在其基础上再偏移0x08就是kernel32.dll在内存中的加载基地址</p><p>（7）从kernrl32.dll的加载基地址算起，偏移0x3C的地方就是其PE头</p><p>（8）PE头偏移0x78的地方存放着指向函数导出表的指针</p><p>（9）至此，我们可以按如下方式在函数导出表中算出所需函数的入口地址</p><ul><li>导出表偏移0x1C处的指针指向存储导出函数偏移地址（RVA）的列表</li><li>导出表偏移0x20处的指针指向存储导出函数函数名的列表</li><li>函数的RVA地址和名字按照顺序存放在上述两个列表中，我们可以在名称列表中定位到所需的函数是第几个，然后在地址列表中找到对应的RVA</li><li>获得RVA中，再加上前边已经得到的动态链接库的加载基址，就获得了所需API此刻在内存中的虚拟地址，这个地址就是我们在shellcode中调用需要的地址</li></ul><p>PS：在寻找kernel32.dll的基地址时，需要将ECX指向的数据取出来，将其作为地址再次赋值给ECX，这里的地址就是kernel32.dll的地址，说明在内存中链表结构，当前偏移0字节的地址就是下一个结点的地址。</p><p>PUSHAD：Push EAX,ECX,EDX,EBX, original ESP,EBP,ESI, and EDI</p><p>ROR:循环右移指令</p><p>;SHL(Shift Left):             逻辑左移<br>;SHR(Shift Right):            逻辑右移<br>;SAL(Shift Arithmetic Left):  算术左移<br>;SAR(Shift Arithmetic Right): 算术右移</p><p>;其中的 SHL 和 SAL 相同, 但 SHR 和 SAR 不同.</p><p>;SHL、SAL: 每位左移, 低位补 0,  高位进 CF<br>;SHR     : 每位右移, 低位进 CF, 高位补 0<br>;SAR     : 每位右移, 低位进 CF, 高位不变</p><p>;它们的结果影响 OF、SF、ZF、PF、CF<br>;它们的指令格式相同:<br>SHL r/m, i8<br>SHL r/m, CL</p><p>ROL、ROR、RCL、RCR: 循环移位指令</p><p>;ROL(Rotate Left):                循环左移<br>;ROR(Rotate Right):               循环右移<br>;RCL(Rotate through Carry Left):  带进位循环左移<br>;RCR(Rotate through Carry Right): 带进位循环右移</p><p>;ROL: 循环左移, 高位到低位并送 CF<br>;ROR: 循环右移, 低位到高位并送 CF<br>;RCL: 循环左移, 进位值(原CF)到低位, 高位进 CF<br>;RCR: 循环右移, 进位值(原CF)到高位, 低位进 CF</p><p>;它们的结果影响 OF、CF<br>;它们的指令格式相同:<br>SHL r/m, i8<br>SHL r/m, CL</p><p>STOSD：For legacy mode,store EAX at address ES:(E)DI;for 64-bit mode store EAX at address RDI or EDI.</p><pre><code class="hljs c"><span class="hljs-keyword">char</span> popup_general[] = <span class="hljs-string">"\x68\x6A\x0A\x38\x1E\x68\x63\x89"</span><span class="hljs-string">"\xD1\x4F\x68\x32\x74\x91\x0C\x8B"</span><span class="hljs-string">"\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04"</span><span class="hljs-string">"\x2B\xE3\x66\xBB\x33\x32\x53\x68"</span><span class="hljs-string">"\x75\x73\x65\x72\x54\x33\xD2\x64"</span><span class="hljs-string">"\x8B\x5A\x30\x8B\x4B\x0C\x8B\x49"</span><span class="hljs-string">"\x1C\x8B\x09\x8B\x69\x08\xAD\x3D"</span><span class="hljs-string">"\x6A\x0A\x38\x1E\x75\x05\x95\xFF"</span><span class="hljs-string">"\x57\xF8\x95\x60\x8B\x45\x3C\x8B"</span><span class="hljs-string">"\x4C\x05\x78\x03\xCD\x8B\x59\x20"</span><span class="hljs-string">"\x03\xDD\x33\xFF\x47\x8B\x34\xBB"</span><span class="hljs-string">"\x03\xF5\x99\x0F\xBE\x06\x3A\xC4"</span><span class="hljs-string">"\x74\x08\xC1\xCA\x07\x03\xD0\x46"</span><span class="hljs-string">"\xEB\xF1\x3B\x54\x24\x1C\x75\xE4"</span><span class="hljs-string">"\x8B\x59\x24\x03\xDD\x66\x8B\x3C"</span><span class="hljs-string">"\x7B\x8B\x59\x1C\x03\xDD\x03\x2C"</span><span class="hljs-string">"\xBB\x95\x5F\xAB\x57\x61\x3D\x6A"</span><span class="hljs-string">"\x0A\x38\x1E\x75\xA9\x33\xDB\x53"</span><span class="hljs-string">"\x68\x77\x65\x73\x74\x68\x66\x61"</span><span class="hljs-string">"\x69\x6C\x8B\xC4\x53\x50\x50\x53"</span><span class="hljs-string">"\xFF\x57\xFC\x53\xFF\x57\xF8"</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;__asm&#123;lea eax,popup_generalpush eaxret&#125;&#125;</code></pre><p>很好奇，这里的shellcode是运行了动态的API地址，但是在前面并没有加载kernel32.dll的组件，程序运行成功，动态的获取了API的地址，运行直接调用messageBoxA函数的地址，可以直接运行成功，而在之前运行静态API函数地址的时候，如果在程序中没有加载kernel32.dll的组件，程序就会出现错误，不能成功运行，这里的原因还不是很清楚。PS：这里看到书P105页，突然发现，这段代码中运行了LoadLibraryA这个函数。</p><p><img src="/images/1556886164887.png" srcset="/img/loading.gif" alt="1556886164887"><br><img src="/images/f95fbe65fffd2467b3fdad7293b6b0d6.jpg" srcset="/img/loading.gif" alt="f9"><br><strong>由于是通过调用ExitProcess退出程序，所以不用担心堆栈平衡等内存细节</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>shellcode</tag>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
